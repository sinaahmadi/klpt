<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Kurdish Language Processing Toolkit">
    <meta name="author" content="Sina Ahmadi">
    <link rel="canonical" href="https://sinaahmadi.github.io/klpt/user-guide/stem/">
    <link rel="shortcut icon" href="../../img/favicon.ico">

    
    <title>Stem - KLPT</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/dracula.min.css">
        
    
    <link href="../../assets/_mkdocstrings.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="../..">KLPT</a>
            
        </div>


        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../getting-started/">Getting started</a>
</li>

                        
                            
<li >
    <a href="../preprocess/">Preprocess</a>
</li>

                        
                            
<li >
    <a href="../tokenize/">Tokenize</a>
</li>

                        
                            
<li >
    <a href="../transliterate/">Transliterate</a>
</li>

                        
                            
<li class="active">
    <a href="./">Stem</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../about/release-notes/">Release Notes</a>
</li>

                        
                            
<li >
    <a href="../../about/contributing/">Contributing</a>
</li>

                        
                            
<li >
    <a href="../../about/sponsors/">Sponsors</a>
</li>

                        
                            
<li >
    <a href="../../about/license/">License</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../transliterate/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../../about/release-notes/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/sinaahmadi/klpt/"><i class="fab fa-github"></i> GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3">
<div class="bs-sidebar hidden-print affix well" role="complementary">

    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#stem-package">stem package</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem">klpt.stem.Stem</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.analyze">analyze()</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.check_spelling">check_spelling()</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.clean_stem">clean_stem()</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.correct_spelling">correct_spelling()</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.lemmatize">lemmatize()</a></li>
        <li class="first-level "><a href="#klpt.stem.Stem.stem">stem()</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="stem-package"><code>stem</code> package</h2>


  <div class="doc doc-object doc-class">

<a id="klpt.stem.Stem"></a>
    <div class="doc doc-contents first">

      <p>The Stem module deals with various tasks, mainly through the following functions:
    - <code>check_spelling</code>: spell error detection
    - <code>correct_spelling</code>: spell error correction
    - <code>analyze</code>: morphological analysis
    - <code>stem</code>: stemming, e.g. "بڕاوە" → "بڕ"
    - <code>lemmatize</code>: lemmatization, e.g. "بردمنەوە" → "بردن"</p>
<p>It is recommended that this module be used on tokens using the tokenization module. 
Please note that only Sorani is supported in this version in this module. The module is based on the <a href="https://github.com/sinaahmadi/KurdishHunspell">Kurdish Hunspell project</a>.</p>
<p>Regarding stemming, the following procedure is followed:
    - for tokens of a single word, as "kirin" (to do), the stem of the token is returned.
    - for compound forms and multi-word expressions, the stem of the noun, adjective or adverb are taken into account. For instance, in the light verbal constructions such as "bar kirin" (to load), the stem of the nominal component "bar" is returned. In other cases, the stem of that part of the MWE token is returned that is semantically more important, as in "دەست تێ وەردان" (dest-tê-werdan) where the stem of "dest" is returned.</p>

<p><strong>Examples:</strong></p>
    
      <pre><code class="language-python">&gt;&gt;&gt; from klpt.stem import Stem
&gt;&gt;&gt; stemmer = Stem(&quot;Sorani&quot;, &quot;Arabic&quot;)
&gt;&gt;&gt; stemmer.check_spelling(&quot;سوتاندبووت&quot;)
False
&gt;&gt;&gt; stemmer.correct_spelling(&quot;سوتاندبووت&quot;)
(False, ['ستاندبووت', 'سووتاندبووت', 'سووڕاندبووت', 'ڕووتاندبووت', 'فەوتاندبووت', 'بووژاندبووت'])
&gt;&gt;&gt; stemmer.analyze(&quot;دیتبامن&quot;)
[{'pos': ['verb'], 'description': 'past_stem_transitive_active', 'stem': 'دی', 'lemma': ['دیتن'], 'base': 'دیت', 'prefixes': '', 'suffixes': 'بامن'}]
&gt;&gt;&gt; stemmer.stem(&quot;دەچینەوە&quot;)
['چ']
&gt;&gt;&gt; stemmer.stem(&quot;گورەکە&quot;, mark_unknown=True)
['_گور_']
&gt;&gt;&gt; stemmer.lemmatize(&quot;گوڵەکانم&quot;))
['گوڵ', 'گوڵە']

&gt;&gt;&gt; stemmer = Stem(&quot;Kurmanji&quot;, &quot;Latin&quot;)
&gt;&gt;&gt; stemmer.analyze(&quot;dibêjim&quot;)
[{'base': 'gotin', 'description': 'vblex_tv_pri_p1_sg', 'pos': '', 'terminal_suffix': '', 'formation': ''}]
</code></pre>




  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.analyze" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_form</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>Morphological analysis of a given word.</p>
<p>It returns morphological analyses. The morphological analysis is returned as a dictionary as follows:</p>
<ul>
<li>"pos": the part-of-speech of the word-form according to <a href="https://universaldependencies.org/u/pos/index.html">the Universal Dependency tag set</a>. </li>
<li>"description": is flag</li>
<li>"prefixes": anything appearing before the base</li>
<li>"suffixes": anything appearing after the base</li>
<li>"st": the stem of the word</li>
<li>"lem": the lemma of the word</li>
<li>"formation": if ds flag is set, its value is assigned to description and the value of formation is set to derivational. Although the majority of our morphological rules cover inflectional forms, it is not accurate to say all of them are inflectional. Therefore, we only set this value to derivational wherever we are sure.</li>
<li>"base": <code>ts</code> flag. The definition of terminal suffix is a bit tricky in Hunspell. According to <a href="http://manpages.ubuntu.com/manpages/trusty/en/man4/hunspell.4.html">the Hunspell documentation</a>, "Terminal suffix fields are inflectional suffix fields "removed" by additional (not terminal) suffixes". In other words, the ts flag in Hunspell represents whatever is left after stripping all affixes. Therefore, it is the morphological base.</li>
</ul>
<p>As for the word "دیتبامن" (that I have seen them), the morphological analysis would look like this: [{'pos': ['verb'], 'description': 'past_stem_transitive_active', 'stem': 'دی', 'lemma': ['دیتن'], 'base': 'دیت', 'prefixes': '', 'suffixes': 'بامن'}]
If the input cannot be analyzed morphologically, an empty list is returned.</p>
<p>Sorani: 
More details regarding Sorani Kurdish morphological analysis can be found at <a href="https://github.com/sinaahmadi/KurdishHunspell">https://github.com/sinaahmadi/KurdishHunspell</a>.</p>
<p>Kurmanji:
Regarding Kurmanji, we use the morphological analyzer provided by the <a href="https://github.com/apertium/apertium-kmr">Kurmanji part</a></p>
<p>Please note that there are delicate difference between who the analyzers work in Hunspell and Apertium. For instane, the <code>base</code> in the Kurmanji analysis refers to the lemma while in Sorani (from Hunspell), it refers to the morphological base.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word_form</code></td>
        <td><code>str</code></td>
        <td><p>a single word-form</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>only string as input</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(list(dict))</code></td>
      <td><p>a list of all possible morphological analyses according to the defined morphological rules</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_form</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Morphological analysis of a given word.</span>

<span class="sd">    It returns morphological analyses. The morphological analysis is returned as a dictionary as follows:</span>

<span class="sd">    - &quot;pos&quot;: the part-of-speech of the word-form according to [the Universal Dependency tag set](https://universaldependencies.org/u/pos/index.html). </span>
<span class="sd">    - &quot;description&quot;: is flag</span>
<span class="sd">    - &quot;prefixes&quot;: anything appearing before the base</span>
<span class="sd">    - &quot;suffixes&quot;: anything appearing after the base</span>
<span class="sd">    - &quot;st&quot;: the stem of the word</span>
<span class="sd">    - &quot;lem&quot;: the lemma of the word</span>
<span class="sd">    - &quot;formation&quot;: if ds flag is set, its value is assigned to description and the value of formation is set to derivational. Although the majority of our morphological rules cover inflectional forms, it is not accurate to say all of them are inflectional. Therefore, we only set this value to derivational wherever we are sure.</span>
<span class="sd">    - &quot;base&quot;: `ts` flag. The definition of terminal suffix is a bit tricky in Hunspell. According to [the Hunspell documentation](http://manpages.ubuntu.com/manpages/trusty/en/man4/hunspell.4.html), &quot;Terminal suffix fields are inflectional suffix fields &quot;removed&quot; by additional (not terminal) suffixes&quot;. In other words, the ts flag in Hunspell represents whatever is left after stripping all affixes. Therefore, it is the morphological base.</span>

<span class="sd">    As for the word &quot;دیتبامن&quot; (that I have seen them), the morphological analysis would look like this: [{&#39;pos&#39;: [&#39;verb&#39;], &#39;description&#39;: &#39;past_stem_transitive_active&#39;, &#39;stem&#39;: &#39;دی&#39;, &#39;lemma&#39;: [&#39;دیتن&#39;], &#39;base&#39;: &#39;دیت&#39;, &#39;prefixes&#39;: &#39;&#39;, &#39;suffixes&#39;: &#39;بامن&#39;}]</span>
<span class="sd">    If the input cannot be analyzed morphologically, an empty list is returned.</span>

<span class="sd">    Sorani: </span>
<span class="sd">    More details regarding Sorani Kurdish morphological analysis can be found at [https://github.com/sinaahmadi/KurdishHunspell](https://github.com/sinaahmadi/KurdishHunspell).</span>

<span class="sd">    Kurmanji:</span>
<span class="sd">    Regarding Kurmanji, we use the morphological analyzer provided by the [Kurmanji part](https://github.com/apertium/apertium-kmr)</span>

<span class="sd">    Please note that there are delicate difference between who the analyzers work in Hunspell and Apertium. For instane, the `base` in the Kurmanji analysis refers to the lemma while in Sorani (from Hunspell), it refers to the morphological base.</span>

<span class="sd">    Args:</span>
<span class="sd">        word_form (str): a single word-form</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: only string as input</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list(dict)): a list of all possible morphological analyses according to the defined morphological rules</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word_form</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only a word (str) is allowed.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">word_analysis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Sorani&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Arabic&quot;</span><span class="p">:</span>
            <span class="c1"># Given the morphological analysis of a word-form with Hunspell flags, extract relevant information and return a dictionary</span>
            <span class="c1"># print(self.huns.analyze(word_form))</span>
            <span class="k">for</span> <span class="n">analysis</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">word_form</span><span class="p">)):</span>
                <span class="n">analysis_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">analysis</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                    <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ts&quot;</span><span class="p">:</span>
                        <span class="c1"># ts flag exceptionally appears after the value as value:key in the Hunspell output</span>
                        <span class="c1"># anything except the terminal_suffix (ts) is considered to be the base</span>
                        <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">affixes</span> <span class="o">=</span> <span class="n">utility</span><span class="o">.</span><span class="n">extract_prefix_suffix</span><span class="p">(</span><span class="n">word_form</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;prefixes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">affixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;suffixes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">affixes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunspell_flags</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1"># assign the key:value pairs from the Hunspell string output to the dictionary output of the current function</span>
                        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ds&quot;</span><span class="p">:</span>
                            <span class="c1"># for ds flag, add derivation as the formation type, otherwise inflection</span>
                            <span class="n">analysis_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hunspell_flags</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;derivational&quot;</span>
                            <span class="n">analysis_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hunspell_flags</span><span class="p">[</span><span class="s2">&quot;is&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                        <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;st&quot;</span><span class="p">:</span>
                            <span class="c1"># for st flag, stem should be cleaned first</span>
                            <span class="n">analysis_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hunspell_flags</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># remove I, T or V using clean_stem()</span>
                            <span class="n">analysis_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hunspell_flags</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># convert lemma and pos to a list and split based on _ when there is more than one output, e.g. more than one lemma for a given word</span>
                <span class="k">if</span> <span class="s2">&quot;lemma&quot;</span> <span class="ow">in</span> <span class="n">analysis_dict</span><span class="p">:</span>
                    <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

                <span class="k">if</span> <span class="s2">&quot;pos&quot;</span> <span class="ow">in</span> <span class="n">analysis_dict</span><span class="p">:</span>
                    <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

                <span class="c1"># for nouns, base is lemma</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="s2">&quot;verb&quot;</span><span class="p">]:</span>
                    <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]]</span>

                <span class="n">word_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">analysis_dict</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Kurmanji&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Latin&quot;</span><span class="p">:</span>
            <span class="n">att_analysis</span> <span class="o">=</span> <span class="n">Analysis</span><span class="p">(</span><span class="s2">&quot;Kurmanji&quot;</span><span class="p">,</span> <span class="s2">&quot;Latin&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">word_form</span><span class="p">)</span>

            <span class="c1"># check if the word-form is analyzed or no</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">att_analysis</span><span class="p">):</span>
                <span class="c1"># the word-form could not be analyzed</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">analysis</span> <span class="ow">in</span> <span class="n">att_analysis</span><span class="p">:</span>
                <span class="n">analysis_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">],</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&gt;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;terminal_suffix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">analysis_dict</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="c1"># TODO: the description needs further information extraction in such a way that some values should be assigned to the &quot;pos&quot; key </span>
                <span class="c1"># analysis_dict[&quot;terminal_suffix&quot;] = word_form.replace(analysis_dict[&quot;base&quot;], &quot;&quot;)</span>
                <span class="n">word_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">analysis_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">word_analysis</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.check_spelling" class="doc doc-heading">
<code class="highlight language-python"><span class="n">check_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>Check spelling of a word</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word</code></td>
        <td><code>str</code></td>
        <td><p>input word to be spell-checked</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>only string as input</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool</code></td>
      <td><p>True if the spelling is correct, False if the spelling is incorrect</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">check_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check spelling of a word</span>

<span class="sd">    Args:</span>
<span class="sd">        word (str): input word to be spell-checked</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: only string as input</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the spelling is correct, False if the spelling is incorrect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Sorani&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Arabic&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not supported yet.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">spell</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.clean_stem" class="doc doc-heading">
<code class="highlight language-python"><span class="n">clean_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>Remove extra characters in the stem
The following issue was observed when stemming with Hunspell (version 2.0.2) where
the retrieved stem of a verb is accompanied by the flag of the word, which is an unwanted extra character.
Possible flags are T, V and I. :lf should also be taken into account.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word</code></td>
        <td><code>[str]</code></td>
        <td><p>[stem]</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">clean_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove extra characters in the stem</span>
<span class="sd">    The following issue was observed when stemming with Hunspell (version 2.0.2) where</span>
<span class="sd">    the retrieved stem of a verb is accompanied by the flag of the word, which is an unwanted extra character.</span>
<span class="sd">    Possible flags are T, V and I. :lf should also be taken into account.</span>

<span class="sd">    Args:</span>
<span class="sd">        word ([str]): [stem]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">]:</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">word</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:lf&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.correct_spelling" class="doc doc-heading">
<code class="highlight language-python"><span class="n">correct_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>Correct spelling errors if the input word is incorrect. It returns a tuple where the first element indicates the correctness of the word (True if correct, False if incorrect).
    If the input word is incorrect, suggestions are provided in a list as the second element of the tuple, as (False, []).
    If no suggestion is available, the list is returned empty as (True, []).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word</code></td>
        <td><code>str</code></td>
        <td><p>input word to be spell-checked</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>only string as input</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>tuple (boolean, list)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">correct_spelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct spelling errors if the input word is incorrect. It returns a tuple where the first element indicates the correctness of the word (True if correct, False if incorrect).</span>
<span class="sd">        If the input word is incorrect, suggestions are provided in a list as the second element of the tuple, as (False, []).</span>
<span class="sd">        If no suggestion is available, the list is returned empty as (True, []).</span>

<span class="sd">    Args:</span>
<span class="sd">        word (str): input word to be spell-checked</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: only string as input</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple (boolean, list)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Sorani&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Arabic&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not supported yet.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_spelling</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">suggest</span><span class="p">(</span><span class="n">word</span><span class="p">)))</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.lemmatize" class="doc doc-heading">
<code class="highlight language-python"><span class="n">lemmatize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>A function for lemmatization of words</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word</code></td>
        <td><code>[str]</code></td>
        <td><p>[given a word, return its lemma form, i.e. dictionary entry form]</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>only string as input</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>list of lemma(s)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">lemmatize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A function for lemmatization of words</span>

<span class="sd">    Args:</span>
<span class="sd">        word ([str]): [given a word, return its lemma form, i.e. dictionary entry form]</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: only string as input</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list of lemma(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Sorani&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Arabic&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not supported yet.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">word_analysis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">word_analysis</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]))</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h2 id="klpt.stem.Stem.stem" class="doc doc-heading">
<code class="highlight language-python"><span class="n">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">mark_unknown</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


</h2>

    <div class="doc doc-contents ">

      <p>A function for stemming a single word</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>word</code></td>
        <td><code>str</code></td>
        <td><p>input word to be spell-checked</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mark_unknown</code></td>
        <td><code>False</code></td>
        <td><p>if the given word is unknown in the tagged lexicon, KLPT stems is following rules. Such stems can be marked with "_" if this variable set to True</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>only string as input</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>list of stem(s)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>klpt/stem.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">mark_unknown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A function for stemming a single word</span>

<span class="sd">    Args:</span>
<span class="sd">        word (str): input word to be spell-checked</span>
<span class="sd">        mark_unknown (False): if the given word is unknown in the tagged lexicon, KLPT stems is following rules. Such stems can be marked with &quot;_&quot; if this variable set to True</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: only string as input</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list of stem(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">==</span> <span class="s2">&quot;Sorani&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">==</span> <span class="s2">&quot;Arabic&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not supported yet.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">stems</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># not detected by Hunspell or the word doesn&#39;t exist in the tagged lexicon</span>
            <span class="k">for</span> <span class="n">verb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_verbs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">verb</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">verb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">verb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">):</span>
                        <span class="c1"># the word is a compound form with a light verb. The other part can be stemmed by Hunspell</span>
                        <span class="k">return</span> <span class="n">stems</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># the word is a compound form with a light verb but the other part cannot be stemmed by Hunspell</span>
                        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">verb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="c1"># the other part of the word or the whole word cannot be stemmed by Hunspell</span>
            <span class="c1"># so, find the stem following morphological rules by checking if removing possible prefixes and suffixes would help finding the stem</span>
            <span class="c1"># Note: even though the same morphemes used in the tokenization system are used in the rules here, there is a delicate difference.</span>
            <span class="c1">#    In the tokenization system, the trimming is done in such a way that shorter morphemes are first checked for suffixes (suffixes in the json file is sorted by length) and </span>
            <span class="c1">#    longer prefixes are trimmer first.</span>
            <span class="c1">#    For the stemmer, however, we do differently by first checking the longer morphemes then shorter ones (for both prefixes and suffixes). </span>
            <span class="c1">#    This is due to the different purposes of the two tasks. Therefore, the list of the morphemes is to be reversed for suffixes (not prefixes). </span>

            <span class="k">for</span> <span class="n">preposition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphemes</span><span class="p">[</span><span class="s2">&quot;prefixes&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">preposition</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">preposition</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">preposition</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])]))):</span>
                        <span class="n">stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">preposition</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])]))</span>
                        <span class="k">if</span> <span class="n">mark_unknown</span><span class="p">:</span>
                            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">preposition</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">break</span>

            <span class="k">for</span> <span class="n">postposition</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphemes</span><span class="p">[</span><span class="s2">&quot;suffixes&quot;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">postposition</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">postposition</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">postposition</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]))):</span>
                        <span class="n">stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_stem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">huns</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">postposition</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]))</span>
                        <span class="k">if</span> <span class="n">mark_unknown</span><span class="p">:</span>
                            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">postposition</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">break</span>

            <span class="c1"># not possible to stem the word using the tagged lexicon or the rule-based approach. Return the word as it is.</span>
            <span class="k">if</span> <span class="n">mark_unknown</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">word</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Kurdish Language Processing Toolkit</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/sinaahmadi/klpt" property="cc:attributionName" rel="cc:attributionURL">Sina Ahmadi</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></small><br>
            
            <small>&copy; 2020 KLPT - Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          <br>
            <small>Revised on: 2020-11-12</small>
          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/python.min.js"></script>
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/json.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = "../.."</script>
    
    <script src="../../js/base.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
